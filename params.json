{"name":"Capsule","tagline":"Dead-Simple Packaging and Deployment for JVM Apps","body":"# Capsule\r\n\r\n## Dead-Simple Packaging and Deployment for JVM Applications\r\n\r\nCapsule is a dead-easy deployment package for standalone JVM applications. Capsule lets you package your entire application into a single JAR file and run it like this `java -jar app.jar`. That's it. You don't need platform-specific startup scripts, and no JVM flags: the application capsule contains all the JVM configuration options. It supports native libraries, custom boot class-path, and Java agents. It can automatically download Maven dependencies when the program is first launched if you choose not to embed them in the capsule, and it can even automatically download a new version of your application when it is published to a Maven repository.\r\n\r\n### Cool Stuff You Can Do with Capsules\r\n\r\n* Have your JAR automatically choose an appropriate JVM version, set JVM flags, and add an embedded JAR to the boot class path.\r\n* Embded any required native libraries directly in the JAR, and Capsule automatically makes sure your application finds them.\r\n* Distribute your application as an \"executable WAR\": it can be deployed to a servlet container *or*, if executed directly, it will automatically download Jetty and deploy itself into the embedded container.\r\n* Distribute a Clojure application without embedding Clojure itself in the capsule, and have Clojure downloaded the first time the capsule is launched. The Clojure runtime will be cached shared among all Clojure capsules so it will only be downloaded once.\r\n* Distribute an Avatar.js application as a JAR containing only JavaScript files, and have Avatar (including its required native libraries) downloaded automatically the first time the application is launched. The Avatar runtime will be cached for later use and shared among other Avatar capules.\r\n* Use a caplet to turn any capsule into a Docker image or to launch it inside a Linux Container.\r\n\r\n### How Capsule Works\r\n\r\nWhen you include the Capsule class in your JAR file and set it to serve as the JAR's main class, Capsule reads various configuration values (like JVM arguments, environment variables, Maven dependencies and more) from the JAR's manifest. It then downloads all required Maven dependencies, if any, and optionally extracts the JAR's contents into a cache directory. It then picks a JVM installation based on the version requirements in the manifest, and finally, it spawns another JVM process to run your application as configured.\r\n\r\n### What Capsule Doesn't Do\r\n\r\nCapsule doesn't contain a JVM distribution, the application user would need to have a JRE installed. Java 9 is expected to have a mechanism for packaging stripped-down versions of the JVM.\r\n\r\n### Overhead\r\n\r\nA \"fat\" capsule (one with all dependencies embedded in the capsule JAR), adds about 100ms to the startup time. A \"thin\" capsule (one with external dependencies, downloaded at first launch), adds about 500ms to the launch time, once the dependencies have been downloaded and cached during the first launch.\r\n\r\nIn terms of JAR size, fat capsules add negligible overhead, while thin capsules add 1.5MB (for the code responsible to downloading and resolving the external dependencies) -- but they don't require the dependencies to be embedded in the JAR, so there's overall savings in deliverable size.\r\n\r\n### Alternatives to Capsule\r\n\r\nThere are a few alternatives to packaging your application in a single JAR. [Maven's Shade plugin](http://maven.apache.org/plugins/maven-shade-plugin/)/[Gradle's Shadow plugin](https://github.com/johnrengelman/shadow) rename dependency classes and might interfere with the application in subtle ways; they also don't support native libraries. [One-Jar](http://one-jar.sourceforge.net/) does support native libraries, but uses class-loader hacks that may interfere with the application in even subtler ways. And none of these support JVM arguments. Shade/Shadow, however, are suitable for distributing libraries, while Capsule only works for applications.\r\n\r\nThe only distribution mechanism supporting JVM arguments and Java version selection is platform-dependent startup scripts. Even if your build tool can generate those for you, they would always require some form of installation by the user.\r\n\r\nWith Capsule, you just distribute a single JAR and run it.\r\n\r\n### Getting Capsule\r\n\r\n[Download](https://github.com/puniverse/capsule/releases)\r\n\r\nor:\r\n\r\n    co.paralleluniverse:capsule:0.10.0\r\n\r\non Maven Central.\r\n\r\n### Building Capsule\r\n\r\n    ./gradlew install\r\n\r\n### Support\r\n\r\nDiscuss Capsule on the capsule-user [Google Group/Mailing List](https://groups.google.com/forum/#!forum/capsule-user)\r\n\r\n### Build-Tool Plugins\r\n\r\nMaven:\r\n\r\n  * https://github.com/chrischristo/capsule-maven-plugin\r\n  * https://github.com/pguedes/capsule-maven-plugin (limited functionality)\r\n\r\nGradle:\r\n\r\n  * https://github.com/danthegoodman/gradle-capsule-plugin\r\n\r\nLeiningen:\r\n\r\n  * https://github.com/circlespainter/lein-capsule\r\n\r\n## Usage Examples\r\n\r\nBefore we delve into the specifics of defining a Capsule distribution, let us look at a few different ways of packaging a capsule. The configurations described below can be built using any JVM build tool. The complete usage example, with both Gradle and Maven build files, is found in the [capsule-demo](https://github.com/puniverse/capsule-demo) project.\r\n\r\nThe first example creates what may be called a *fat* capsule. The capsule JAR has the following structure:\r\n\r\n    foo.jar\r\n    |__ Capsule.class\r\n    |__ app.jar\r\n    |__ dep1.jar\r\n    |__ dep2.jar\r\n    \\__ MANIFEST\r\n        \\__ MANIFEST.MF\r\n\r\nWith the manifest (`MANIFEST.MF`) being:\r\n\r\n    Manifest-Version: 1.0\r\n    Main-Class: Capsule\r\n    Application-Class: foo.Main\r\n    Min-Java-Version: 1.8.0\r\n    JVM-Args: -server\r\n    System-Properties: foo.bar.option=15 my.logging=verbose\r\n    Java-Agents: dep2.jar\r\n\r\nWe embed the application JAR (`app.jar`) as well as all dependency JARs into the capsule JAR (without extracting them). We also include the `Capsule` class in the JAR.\r\nThen, in the JAR's manifest, we declare `Capsule` as the main class. This is the class that will be executed when we run `java -jar foo.jar`. The `Application-Class` attribute tells Capsule which class to run in the new JVM process, and we set it to the same value, `mainClass` used by the build's `run` task. The `Min-Java-Version` attribute specifies the JVM version that will be used to run the application. If this version is newer than the Java version used to launch the capsule, Capsule will look for an appropriate JRE installation to use (a maximum version can also be specified with the `Java-Version` attribute). We then also specify JVM arguments, system properties and even a Java agent.\r\n\r\nWhen we run the capsule with `java -jar foo.jar`, its contents will be extracted into a cache directory (whose location can be customized).\r\n\r\nThis kind of capsule has the advantage of being completely self-contained, and it does not require online access to run. The downside is that it can be rather large, as all dependencies are stuffed into the JAR.\r\n\r\nThe second kind of capsule -- a *thin* capsule -- does not embed the app's dependencies in the JAR, but downloads them when first run. The capsule JAR looks like this:\r\n\r\n    foo.jar\r\n    |__ Capsule.class\r\n    |__ capsule/\r\n    |    \\__ [capsule classes]\r\n    |__ com/\r\n    |   \\__ acme/\r\n    |       \\__ [app classes]\r\n    \\__ MANIFEST/\r\n        \\__ MANIFEST.MF\r\n\r\nWith the manifest being:\r\n\r\n    Manifest-Version: 1.0\r\n    Main-Class: Capsule\r\n    Application-Class: foo.Main\r\n    Min-Java-Version: 1.8.0\r\n    Extract-Capsule : false\r\n    JVM-Args: -server\r\n    System-Properties: foo.bar.option=15 my.logging=verbose\r\n    Dependencies: com.acme:dep1:1.2 com.acme:dep2:3.4\r\n    Java-Agents: com.acme:dep2:3.4\r\n\r\n\r\nThis capsule doesn't embed the dependencies in the JAR, so our application's classes can be simply placed in it unwrapped. Instead, the `Dependencies` attribute declares the application's dependencies. The first time we run `java -jar foo.jar`, the dependencies will be downloaded (by default from Maven Central, but other Maven repositories may be declared in the manifest). The dependencies are placed in a cache directory shared by all capsules, so common ones like SLF4J or Guava will only be downloaded once. Also, because the app's classes are placed directly in the JAR, and the dependencies are loaded to a shared cache, the capsule does not need to be extracted to the filesystem at all, hence the manifest says `Extract-Capsule : false`.\r\n\r\nInstead of specifying the dependencies and (optionally) the repositories directly in the manifest, if the capsule contains a `pom.xml` file in the JAR root, it will be used to find the dependencies.\r\n\r\nIn order to support Maven dependencies, we needed to include all of Capsule's classes in the capsule JAR rather than just the `Capsule` class. This will add about 1.5MB to the (compressed) JAR, but will save a lot more by not embedding all the dependencies.\r\n\r\nApart from the *thin* and *fat* extremes, Capsule supports anything in between: it is possible to embed some dependencies while declaring others in the manifest (or `pom.xml`) and letting Capsule retrieve them upon first run. Please note that whenever a capsule needs to retrieve even just some Maven artifacts, its JAR needs to include all of Capsule's classes.\r\n\r\nFinally, a capsule may not contain any of the application's classes/JARs at all. The capsule's manifest can contain these two attributes:\r\n\r\n    Main-Class: Capsule\r\n    Application: com.acme:foo\r\n\r\nAnd when the capsule is launched, the newest available version of the application will be downloaded, cached and launched. In this use-case, the capsule JAR looks like this:\r\n\r\n    foo.jar\r\n    |__ Capsule.class\r\n    |__ capsule/\r\n    |    \\__ [capsule classes]\r\n    \\__ MANIFEST/\r\n        \\__ MANIFEST.MF\r\n\r\nNote how none of the application's classes are actually found in the JAR.\r\n\r\n## User Guide\r\n\r\nA capsule requires two attributes in its manifest file. The first, is the same for all capsules:\r\n\r\n    Main-Class : Capsule\r\n\r\nThis attributes makes the JAR file into a capsule. The second attribute tells the capsule what to run when launched. It must be one of:\r\n\r\n    Application-Class : [the applications's main class, found in the capsule or one of its dependencies]\r\n\r\nwhich specifies the application's main class, or,\r\n\r\n    Application : [the Maven coordinates of the application's main JAR or the path of the main JAR within the capsule]\r\n\r\nor,\r\n\r\n    Unix-Script    : [a startup script to be run on *nix machines, found in the capsule]\r\n    Windows-Script : [a startup script to be run on Windows machines, found in the capsule]\r\n\r\nThese attributes are sufficient to build a capsule, but there are many other configuration options, which will be explained below.\r\n\r\n### Launching the Capsule\r\n\r\nAs mentioned before, `java -jar app.jar [app arguments]` will launch the application.\r\n\r\nThe `java -Dcapsule.version -jar app.jar` command will print the application ID, the version of Capsule used, and then exit without launching the app.\r\n\r\nCapsule's JAR can be used standalone (without merging with any application binaries), to launch applications stored in a Maven repository like so:\r\n\r\n    java -jar capsule.jar com.acme:foo [app arguments]\r\n\r\nThe above command will download (and cache) the Maven artifact and its dependencies, and run it, provided that it's a capsule itself, or even any executable JAR.\r\n\r\nAdding `-Dcapsule.log=verbose` or `-Dcapsule.log=debug`  before `-jar` will print information about Capsule's action.\r\n\r\n### Capsule Configuration and Modes\r\n\r\nA capsule is (mostly) configured by attributes in its manifest. Manifest attributes specify which Java version to use when launching the application, what agents to load, the JVM arguments, system properties, dependencies and more.\r\n\r\nIt is possible to specify different values for each of the configurations -- to be selected at launch time -- by creating several capsule *modes*. Modes are defined by manifest sections, each section's name corresponds to the mode. Attributes in the manifest's main section are used in the default mode, and those listed in the named sections can override them when the respective node is selected (configurations without overrides will be taken from the main section).\r\n\r\nExample:\r\n\r\n    Attribute-X: foo\r\n    Attribute-Y: bar\r\n\r\n    Name: Special\r\n    Attribute-Y: baz\r\n\r\nWhen running in the `Special` mode, `Attribute-Y` will have the value `baz`, while the non-overriden `Attribute-X` will have the value `foo`, as in the default mode.\r\n\r\nTo select a non default mode, you launch the capsule with the `-Dcapsule.mode=MODE` command line argument.\r\n\r\nThe `Application-Name` and `Application-Version` attributes (see the next section) can only be listed in the manifest's main section.\r\n\r\n### Application ID\r\n\r\nThe application ID is used to find the capsule's application cache, where the capsule's contents will be extracted if necessary. If the manifest has an `Application-Name`, it will be the application's ID, combined with the `Application-Version` attribute, if found. If there is no `Application-Name` attribute, and a `pom.xml` file is found in the JAR's root, the ID will be formed by joining the POM's groupId, artifactId, and version properties. If there is no POM file, the `Application-Class` attribute will serve as the application name.\r\n\r\nWhen authoring a capsule, please ensure a unique ID by setting `Application-Name` to a domain-qualified name (e.g. `acme.best_app`).\r\n\r\n### Selecting the Java Runtime\r\n\r\nTwo manifest attributes determine which Java installation Capsule will use to launch the application. `Min-Java-Version` (e.g. `1.7.0_50` or `1.8.0`) is the lowest Java version to use, while `Java-Version` (e.g. `1.6`) is the highest *major* Java version to use. One, both, or neither of these attributes may be specified in the manifest.\r\n\r\nFirst, Capsule will test the current JVM (used to launch the capsule) against `Min-Java-Version` and `Java-Version` (if they're specified). If the version of the current JVM matches the requested range, it will be used to launch the application. If not, Capsule will search for other JVM installations, and use the one with the highest version that matches the requested range. If no matching installation is found, the capsule will fail to launch.\r\n\r\nIt is also possible to require a minimal update version, say, in cases where the update fixes a bug affecting the application. Because the bug may have been fixed in two different major versions in two different updates (e.g., for Java 7 in update 85, and for Java 8 in update 21), the minimal update required is specified per major Java version, in the `Min-Update-Version` attribute. For example\r\n\r\n    Min-Update-Version: 7=85 1.8=21\r\n\r\nThe major version can be given as a single digit (`7`) or as a \"formal\" Java version (`1.7`, or, `1.7.0`). The updates are specified in a whitespace separated list of entries, each entry containing a key (the major version) and a value (the minimum update) as a `=` separated pair.\r\n\r\nIf the `JDK-Required` attribute is set to `true`, Capsule will only select JDK installations.\r\n\r\nWhatever the `Min-Java-Version`, `Java-Version`, or `JDK-Required` attributes specify, launching the capsule with the `capsule.java.home` system property, will use whatever Java installation is specified by the property, for example: `java -Dcapsule.java.home=/Library/Java/JavaVirtualMachines/jdk1.8.0.jdk/Contents/Home -jar app.jar`.\r\n\r\nFinally, setting the `capsule.java.cmd` system property with the path to the executable which will be used to launch the JVM, overrides any JRE selection mechanism.\r\n\r\nRunning `java -Dcapsule.jvms -jar app.jar` will list all Java installations Capsule can find, and then quit without launching the app.\r\n\r\n### Capsule's Cache\r\n\r\nBy default, Capsule will extract the capsule JAR's contents -- except for class files placed directly in the JAR -- into a cache directory. If the\r\n`Extract-Capsule` manifest attribute is set to `false`, the JAR will not be extracted.\r\n\r\nThe capsule will be extracted once. Following run will compare the JAR's modification date with that of the cache, and will re-write the cache only if the capsule JAR is younger. You can force re-extraction of the capsule with `-Dcapsule.reset=true`.\r\n\r\nThe location of the cache and the location of the JAR are communicated to the application through the `capsule.dir` and `capsule.jar` system properties respectively. Capsule defines these properties automatically, and the application may use them, for example, to find extracted resources. In addition, those two filesystem paths can be used within the manifest itself to set various values (system properties, environment variables, etc) by referencing them with `$CAPSULE_DIR` and `$CAPSULE_JAR` respectively.\r\n\r\nUsing the values in `capsule.dir` or `CAPSULE_DIR` to directly access the cache is generally discouraged, and should be a last resort (but a working one, nonetheless), as it depends on Capsule's inner workings.\r\n\r\nCapsule's cache is found, by default, at `~/.capsule/` on Unix/Linux/Mac OS machines, and at `%USERPROFILE%\\AppData\\Local\\capsule\\` on Windows. The application caches are placed in the `apps/APP_ID` subdirectory of the cache, while the shared dependency cache is at the `deps` subdirectory. The location of the Capsule cache can be changed with environment variables: setting `CAPSULE_CACHE_NAME` determines the name of the topmost Capsule cache dir (i.e. \"capsule\" by default), while `CAPSULE_CACHE_DIR` can be used to set a precise path for the cache (e.g. `/tmp/capsule/).\r\n\r\n### Maven Dependencies\r\n\r\nThe capsule can specify external dependencies as coordinates in Maven repositories. One way of specifying dependencies, is placing the app's `pom.xml` file in the capsule JAR's root. Another is specifying the dependencies and repositories in the capsule's manifest.\r\n\r\nBy default, Capsule will look for dependencies on Maven Central. If other repositories are needed (or if you don't want to access Maven Central), the `Repositories` attribute is a space-separated list of Maven repository URLs. The repositories will be searched in the order they are listed. If the `Repositories` attribute is found in the manifest, then Maven Central will not be searched.\r\n\r\nInstead of specifying explicit URLs, the following well-known repository names can be listed in the `Repositories` attribute:\r\n\r\n* `central` - Maven central, HTTPS\r\n* `central-http` - Maven central, HTTP\r\n* `jcenter` - jCenter, HTTPS\r\n* `jcenter-http` - jCenter, HTTP\r\n* `local` - Default local Maven repository (`userdir/.m2/repository`). You should only use local repositories in tests.\r\n\r\nCapsule also automatically uses the information in Maven's `settings.xml` file to access repositories that require authentication. The `settings.xml` used is the user's settings (in the `.m2` directory in the user's home directory), or in the global settings (in the `conf` subdirectory of the Maven installation). A `settings.xml` file is absolutely not required for Capsule's operation, and is mostly useful when accessing private organizational Maven repositories for dependencies.\r\n\r\nThe dependencies, (if not read from the POM), are listed in the `Dependencies` attribute, as a space-separated list of Maven coordinates in the Gradle format, i.e. `groupId:artifactId:version`. Exclusions can be given as a comma separated list within parentheses, immediately following the main artifact, of `groupId:artifactId` coordinates, where the artifact can be the wildcard `*`. For example:\r\n\r\n    Dependencies : com.esotericsoftware.kryo:kryo:2.23.0(org.ow2.asm:*)\r\n\r\nThe dependencies are downloaded the first time the capsule is launched, and placed in the `deps` subdirectory of the Capsule cache, where they are shared among all capsules.\r\n\r\nThe `CAPSULE_REPOS` environment variable can be set to a *comma-* (`,`) or a whitespace-separated list of Maven repository URLS or well-known repository names (see above), which will be prepended to those specified in the manifest or the POM.\r\n\r\nBy default, SNAPSHOT dependencies are not allowed, unless the `Allow-Snapshots` is set to `true`.\r\n\r\nCapsule can make use of Maven repositories in another way: the `Application` manifest attribute can specify the Maven coordinates of the application's main JAR file, which can in itself be a capsule.\r\n\r\nMaven [version ranges](http://maven.apache.org/enforcer/enforcer-rules/versionRanges.html) (as well as `LATEST` and `RELEASE`) are supported. For example: `Application: com.acme:foo:[1.0,2.0)`. The newest version matching the range (or the newest version if no range is given), will be downloaded, cached and launched. Not specifying a version at all will resolve to the latest release. If the application's main artifact is a capsule, then all configurations will be taken based on those in the artifact capsule.\r\n\r\nNative dependencies can be specified in the `Native-Dependencies-Linux`/`Native-Dependencies-Win`/`Native-Dependencies-Mac` attributes, each for its respective OS. A native dependency is written as a plain dependency but can be followed by a comma and a new filename to give the artifact once downloaded (e.g.: `com.acme:foo-native-linux-x64:1.0,foo-native.so`). Each native artifact must be a single native library, with a suffix matching the OS (`.so` for Linux, `.dll` for windows, `.dylib` for Mac). The native libraries are downloaded and copied into the application cache (and renamed if requested).\r\n\r\nAdding `-Dcapsule.reset=true`, can force a re-download of SNAPSHOT versions.\r\n\r\nThe command: `java -Dcapsule.tree -jar app.jar`, will print the dependency tree for the capsule, and then quit without launching the app.\r\n\r\nTwo more system properties affect the way Capsule searches for dependencies. If `capsule.offline` is defined or set to `true` (`-Dcapsule.offline` or `-Dcapsule.offline=true`), Capsule will not attempt to contact online repositories for dependencies (instead, it will use the local Maven repository/cache only). `capsule.local` determines the path for the local Maven repository/cache Capsule will use (which, by default, is the `deps` subdirectory of the Capsule cache).\r\n\r\n### Class Paths\r\n\r\nBy default, Capsule sets the application's class path to: the capsule JAR itself, the application's cache directory (if the capsule is extracted) and every JAR found in the root of the cache directory (i.e. every JAR file placed in the capsule JAR's root) -- in no particular order -- and, finally, the application's Maven dependencies in the order they are listen in the `Dependencies` attribute or the POM file. Also, if the capsule contains an `Application` attribute, all entries in the `Class-Path` attribute in the manifest of the `Application` JAR are added to the classpath automatically.\r\n\r\nThe classpath, however, can be customized by the `Class-Path` attribute, which can be given an ordered (space separated) list of JARs and/or directories relative to the capsule JAR root. This attribute only applies if the capsule is extracted, and if it is found in the manifest, then all JARs in the cache's root will not be added automatically to the classpath.\r\n\r\nIn addition to setting the application classpath, you can also specify the boot classpath. The `Boot-Class-Path` attribute is, similar to the `Class-Path` attribute, an ordered, space separated list of JARs and/or directories relative to the capsule's root, that will become the application's boot classpath. If you don't want to replace the default Java boot classpath, but simply to tweak it, The `Boot-Class-Path-P` attribute can be used to specify a classpath to be prepended to the default boot classpath, and the `Boot-Class-Path-P` attribute can specify a class path that will be appended to the default.\r\n\r\nIf the capsule is launched with a `-Xbootclasspath` option, it will override any setting by the capsule's manifest.\r\n\r\nThe `Library-Path-A` manifest attribute can list JARs or directories (relative to the capsule's root) that will be appended to the application's native library path. Similarly, `Library-Path-P`, can be used to prepend JARs or directories to the default native library path.\r\n\r\n### JVM Arguments, System Properties, Environment Variables and Java Agents\r\n\r\nThe `JVM-Args` manifest attribute can contain a space-separated list of JVM argument that will be used to launch the application. Any JVM arguments supplied during the capsule's launch, will override those in the manifest. For example, if the `JVM-Args` attribute contains `-Xmx500m`, and the capsule is launched with `java -Xmx800m -jar app.jar`, then the application will be launched with the `-Xmx800m` JVM argument.\r\n\r\nJVM arguments listed on the command line apply both to the Capsule launch process as well as the application process (see *The Capsule Execution Process*). Sometimes this is undesirable (e.g. when specifying a debug port, which can only apply to a single process or a port collision will ensue). JVM arguments for at the application process (only) can be supplied by adding `-Dcapsule.jvm.args=\"MY JVM ARGS\"` to the command line.\r\n\r\nThe `Args` manifest attribute can contain a space-separated list of command line arguments to be passed to the application; these will be prepended to any arguments passed to the capsule at launch.\r\n\r\nThe `System-Properties` manifest attribute can contain a space-separated list of system properties that will be defined in the launched application. The properties are listed as `property=value` pairs (or just `property` for an empty value). Any system properties supplied during the capsule's launch, will override those in the manifest. For example, if the `JVM-Args` attribute contains `name=Mike`, and the capsule is launched with `java -Dname=Jason -jar app.jar`, then the application will see the `name` system-property defined as `Jason`.\r\n\r\nThe `Environment-Variables` manifest attribute, is, just like `System-Properties`, a space-separated list of `var=value` pairs (or just `var` for an empty value). The specified values do not overwrite those already defined in the environment, unless they are listed as `var:=value` rather than `var=value`.\r\n\r\nThe `Java-Agents` attribute can contain a space-separated list with the names of JARs containing Java agents. The agents are listed as `agent=params` or just `agent`, where `agent` is either the path of a JAR embedded in the capsule, relative to the capsule JAR's root, or the coordinates of a Maven dependency.\r\n\r\nRemember that values listed in all these configuration values can contain the `$CAPSULE_DIR` and `$CAPSULE_JAR` variables, discussed in the *Capsule's Cache* section.\r\n\r\n### Scripts\r\n\r\nWhile Capsule mostly makes startup scripts unnecessary, in some circumstances they can be useful. Capsule allows placing platform-specific scripts into the capsule JAR, and executing them instead of launching a JVM and running `Application-Class`. The `Unix-Script` attribute specifies the location (relative to the capsule JAR's root) of a POSIX shell script, to be run on POSIX machines, while `Windows-Script` specifies the location of a Windows script file. If only, say, `Unix-Script` is defined, then on Windows machines Capsule will simply run the `Application-Class` as usual.\r\n\r\nThe scripts can make use of the `CAPSULE_DIR` environment variable to locate capsule files. In addition, Capsule will choose the JVM installation based on the version requirements, and set the `JAVA_HOME` environment variable for the script appropriately.\r\n\r\nScripts cannot be used if the `Extract-Capsule` attribute is `false`.\r\n\r\n### Security Manager\r\n\r\nThe `Security-Policy` attribute specifies a Java [security policy file](http://docs.oracle.com/javase/7/docs/technotes/guides/security/PolicyFiles.html) to use for the application. Its value is the location of the security file relative to the capsule JAR root. The `Security-Policy-A` achieves a similar purpose, only the security policy specified is added to the default one rather than replaces it. Finally, the `Security-Manager` attribute can specify a class to be used as the security manager for the application.\r\n\r\nIf any of these three properties is set, a security manager will be in effect when the application runs. If the `Security-Manager` attribute is not set, the default security manager will be used.\r\n\r\n### Caplets\r\n\r\nYou can customize many of the capsule's inner workings by creating a Caplet -- *custom capsule*. A caplet is a subclass of `Capsule` that overrides some of its overridable methods.\r\n\r\nTo apply the caplets to the capsule you list them, in the order they're to be applied, in the `Caplets` manifest attribute. You can either embed a caplet in your capsule, in which case list its class name in the `Caplet` attribute, or declare it as an external Maven dependency and list it's artifact coordinates.\r\n\r\nPlease consult Capsule's [Javadoc](http://puniverse.github.io/capsule/capsule/javadoc/Capsule.html) for specific documentation on custom capsules.\r\n\r\nSome experimental and very-much-unfunished, yet interesting, caplets are:\r\n\r\n* [capsule-docker]() - Turns a capsule into a [Docker]() image.\r\n* [capsule-osv]() - Builds an OSv image for any capsule.\r\n* [capsule-shield]() - Runs a capsule inside a [Linux Container]().\r\n\r\n### Empty Capsules and Capsule Wrapping\r\n\r\nA capsule that contains no application (i.e., it's manifest has no `Application-Class`, `Application`, `Application-Name` etc.) is known as an *empty capsule*. Most caplets and, in fact, the Capsule project itself, are shipped as binaries which are essentially empty capsules. While you cannot run an empty capsule on its own, empty capsules can serve -- unmodified -- as *capsule wrappers* that wrap other capsules, or even un-capsuled applications. This is most useful when the empty, wrapper, capsule employs caplets to provide some special behavior to the wrapped capsule or application.\r\n\r\nSuppose `capsule.jar` is an empty capsule. We can use it to launch an application stored in a Maven repository like so:\r\n\r\n    java -jar capsule.jar com.acme:coolapp\r\n\r\nOr, if the application is stored in a local JAR:\r\n\r\n    java -jar capsule.jar coolapp.jar\r\n\r\nIn both cases, the only requirement from `coolapp` is that it has a main class declared in its manifest.\r\n\r\nIf coolapp is a capsule rather than a simple application, then our empty capsule will be used as a caplet which will be applied to the wrapped capsule.\r\n\r\n### \"Really Executable\" Capsules\r\n\r\nA JAR file can be made \"really executable\" in UNIX/Linux/MacOS environments -- i.e. it can be run simply as `capsule.jar ARGS` rather than `java -jar capsule.jar ARGS` -- by [prepending a couple of shell script lines to the JAR](http://skife.org/java/unix/2011/06/20/really_executable_jars.html) (it turns out JAR files can tolerate any prepended headers).\r\n\r\nBoth [capsule-maven-plugin](https://github.com/chrischristo/capsule-maven-plugin) and  [gradle-capsule-plugin](https://github.com/danthegoodman/gradle-capsule-plugin) support creation of really executable capsules simply by setting a flag.\r\n\r\nIf you choose not to use one of the capsule plugins, then you can use the [really-executable-jars](https://github.com/brianm/really-executable-jars-maven-plugin) Maven plugin to make your capsule really executable (or if you're using the [capsule-maven-plugin](https://github.com/chrischristo/capsule-maven-plugin), just set the `buildExec` tag to true). In Gradle, this can be done by adding the following function to your build file:\r\n\r\n``` groovy\r\ndef reallyExecutable(jar) {\r\n    ant.concat(destfile: \"tmp.jar\", binary: true) {\r\n        zipentry(zipfile: configurations.capsule.singleFile, name: 'capsule/execheader.sh')\r\n        fileset(dir: jar.destinationDir) {\r\n            include(name: jar.archiveName)\r\n        }\r\n    }\r\n    copy {\r\n        from 'tmp.jar'\r\n        into jar.destinationDir\r\n        rename { jar.archiveName }\r\n    }\r\n    delete 'tmp.jar'\r\n}\r\n```\r\n\r\nand then\r\n\r\n``` groovy\r\ncapsule.doLast { task -> reallyExecutable(task) }\r\n```\r\n\r\n### The Capsule Execution Process\r\n\r\nWhen a capsule is launched, two processes are involved: first, a JVM process runs the capsule launcher, which then starts up a second, child process that runs the actual application. The two processes are linked so that killing or suspending one, will do the same for the other. On UNIX systems (Linux, Mac, etc.), the launcher process makes public the identity of the child process by setting the `capsule.app.pid` system property, which can be queried with the `jcmd` command. Suppose the capsule's pid is 1234, then the child (app) process pid can be obtained with the following shell command:\r\n\r\n    jcmd 1234 VM.system_properties  | grep capsule.app.pid | cut -f 2 -d =\r\n\r\nWhile this model works well enough in most scenarios, sometimes it is desirable to directly launch the process running the application, rather than indirectly. This is supported by \"capsule trampoline\", and is available for really executable capsules on UNIX systems only. To take advantage of capsule trampolining, use the `capsule/trampoline-execheader.sh` executable header (rather than `capsule/execheader.sh`) when creating the really executable capsule.\r\n\r\n### capsule-util\r\n\r\nThe [capsule-util](http://puniverse.github.io/capsule/capsule-util/javadoc/) sub-project contains classes to create and interact with capsule's at runtime. See the Javadocs [here](http://puniverse.github.io/capsule/capsule-util/javadoc/).\r\n\r\n### capsule-build\r\n\r\nThe [capsule-build](http://puniverse.github.io/capsule/capsule-build/javadoc/) sub-project contains utilities used by build-tool plugins that create capsules. See the Javadocs [here](http://puniverse.github.io/capsule/capsule-build/javadoc/).\r\n\r\n## Reference\r\n\r\n### Manifest Attributes\r\n\r\nEverywhere the word \"list\" is mentioned, it is whitespace-separated.\r\n\r\n* `Application-Name`: the name of the application, used to define its ID\r\n* `Application-Version`: the application's version, used to define its ID\r\n* `Application-Class`: the application's main class\r\n* `Application`: the Maven coordinates of the application's main JAR or the path of the main JAR within the capsule\r\n* `Unix-Script`: a startup script to be run *instead* of `Application-Class` on Unix/Linux/Mac OS, given as a path relative to the capsule's root\r\n* `Windows-Script`: a startup script to be run *instead* of `Application-Class` on Windows, given as a path relative to the capsule's root\r\n* `Extract-Capsule`: if `false`, the capsule JAR will not be extracted to the filesystem (default: `true`)\r\n* `Min-Java-Version`: the lowest Java version required to run the application; Capsule will look for an appropriate installation\r\n* `Min-Update-Version`: a space-separated key-value ('=' separated) list mapping Java versions to the minimum update version required\r\n* `Java-Version`: the highest version of the Java installation required to run the application; Capsule will look for an appropriate installation\r\n* `JDK-Required`: if set to `true`, the Capsule will only be launched using a JDK, if one matching the requested versions is found.\r\n* `JVM-Args`: a list of JVM arguments that will be used to launch the application's Java process\r\n* `Args`: the list of command line arguments to be passed to the application; the UNIX shell-style special variables (`$*`, `$1`, `$2`, ...) can refer to the actual arguments passed on the capsule's command line; if no special var is used, the listed values will be prepended to the supplied arguments (i.e., as if `$*` had been listed last).\r\n* `Environment-Variables`: a list of environment variables that will be put in the applications environment; formatted `var=value` or `var`\r\n* `System-Properties`: a list of system properties that will be defined in the applications JVM; formatted `prop=value` or `prop`\r\n* `App-Class-Path`: a list of JARs, relative to the capsule root, that will be put on the application's classpath, in the order they are listed\r\n* `Capsule-In-Class-Path`: if set to `false`, the capsule JAR itself will not be on the application's classpath (default: `true`)\r\n* `Boot-Class-Path`: a list of JARs, dependencies, and/or directories, relative to the capsule root, that will be used as the application's boot classpath.\r\n* `Boot-Class-Path-A`: a list of JARs dependencies, and/or directories, relative to the capsule root, that will be appended to the applications default boot classpath\r\n* `Boot-Class-Path-P`: a list of JARs dependencies, and/or directories, relative to the capsule root, that will be *prepended* to the applications default boot classpath\r\n* `Library-Path-A`: a list of JARs and/or directories, relative to the capsule root, that will be appended to the default native library path\r\n* `Library-Path-P`: a list of JARs and/or directories, relative to the capsule root, that will be *prepended* to the default native library path\r\n* `Security-Manager`: the name of a class that will serve as the application's security-manager\r\n* `Security-Policy`: a security policy file, relative to the capsule root, that will be used as the security policy\r\n* `Security-Policy-A`: a security policy file, relative to the capsule root, that will be appended to the default security policy\r\n* `Java-Agents`: a list of Java agents used by the application; formatted `agent` or `agent=arg1,arg2...`, where agent is either the path to a JAR relative to the capsule root, or a Maven coordinate of a dependency\r\n* `Repositories`: a list of Maven repository URLs\r\n* `Dependencies`: a list of Maven dependencies given as `groupId:artifactId:version[(excludeGroupId:excludeArtifactId,...)]`\r\n* `Allow-Snapshots`: If `true`, allows for SNAPSHOT dependencies (default: `false`)\r\n* `Native-Dependencies-Linux`: a list of Maven dependencies consisting of `.so` artifacts for Linux; each item can be a comma separated pair, with the second component being a new name to give the download artifact. The artifacts will be Windows and copied into the application's cache directory.\r\n* `Native-Dependencies-Win`: a list of Maven dependencies consisting of `.dll` artifacts for Linux; each item can be a comma separated pair, with the second component being a new name to give the download artifact. The artifacts will be downloaded and copied into the application's cache directory.\r\n* `Native-Dependencies-Mac`: a list of Maven dependencies consisting of `.dylib` artifacts for Mac OS X; each item can be a comma separated pair, with the second component being a new name to give the download artifact. The artifacts will be downloaded and copied into the application's cache directory.\r\n* `Capsule-Log-Level`: sets the default log level for the Capsule launcher (which can be overridden with `-Dcapsule.log`); can be one of: `NONE`, `QUIET` (the default), `VERBOSE`, or `DEBUG`.\r\n* `Caplets`: a list of names of caplet classes -- if embedded in the capsule -- or Maven coordinates of caplet artifacts that will be applied to the capsule in the order they are listed.\r\n\r\n### Manifest Variables\r\n\r\n* `$CAPSULE_JAR`: the full path to the capsule JAR\r\n* `$CAPSULE_DIR`: the full path to the application cache directory, if the capsule is extracted.\r\n* `$JAVA_HOME`: the full path to the Java installation which will be used to launch the app\r\n\r\n### System Properties\r\n\r\n* `capsule.version`: if set, the capsule will print the application ID, its Capsule version and quit without launching the app\r\n* `capsule.tree`: if set, the capsule will print the app's dependency tree, and then quit without launching the app\r\n* `capsule.jvms`: if set, the capsule will print the JVM installations it can locate with their versions, and then quit without launching the app\r\n* `capsule.resolve`: all external dependencies, if any, will be downloaded (if not cached already), and/or the capsule will be extracted if necessary, but the application will not be launched\r\n* `capsule.mode`: if set, the capsule will be launched in the specified mode (see *Capsule Configuration and Modes*)\r\n* `capsule.log`: can be set to 'none'/'quiet' (default)/'verbose'/'debug'\r\n* `capsule.jvm.args`: specifies JVM arguments for the capsule's app process.\r\n* `capsule.reset`: if set, forces re-extraction of the capsule, where applies, and/or re-downloading of SNAPSHOT dependencies\r\n* `capsule.java.home`: forces the capsule to use the given path to a Java installation when launching the application.\r\n* `capsule.java.cmd`: firces the capsule to use the give executable to launch the JVM.\r\n* `capsule.offline`: if defined (without a value) or set to `true`, Capsule will not attempt to contact online repositories for dependencies\r\n* `capsule.local`: the path for the local Maven repository; defaults to CAPSULE_CACHE/deps\r\n* `capsule.connect.timeout`: The maximum amount of time (in milliseconds) to wait for a successful connection to a remote repository. Non-positive values indicate no timeout.\r\n* `capsule.request.timeout`: The maximum amount of time (in milliseconds) to wait for remaining data to arrive from a remote repository. Note that this timeout does not restrict the overall duration of a request, it only restricts the duration of inactivity between consecutive data packets. Non-positive values indicate no timeout.\r\n\r\nCapsule defines these system properties in the application's process:\r\n\r\n* `capsule.app`: the app ID\r\n* `capsule.jar`: the full path to the capsule's JAR\r\n* `capsule.dir`: if the JAR has been extracted, the full path of the application cache (use generally discouraged).\r\n\r\nCapsule defines these system properties in the capsule (launcher) process (to be queried by `jcmd`):\r\n\r\n* `capsule.app.pid`: the child (application) process PID; available only in POSIX environments.\r\n\r\n### Environment Variables\r\n\r\n* `CAPSULE_CACHE_NAME`: sets the *name* of the root of Capsule's cache in the default location (`~` on Unix, `%LOCALAPPDATA%` on Windows)\r\n* `CAPSULE_CACHE_DIR`: sets the full path of the Capsule's cache\r\n* `CAPSULE_REPOS`: sets the list -- comma (`,`) or whitespace separated -- of Maven repositories that the capsule will use; overrides those specified in the manifest or the POM.\r\n* `CAPSULE_CONNECT_TIMEOUT`: The maximum amount of time (in milliseconds) to wait for a successful connection to a remote repository. Non-positive values indicate no timeout.\r\n* `CAPSULE_REQUEST_TIMEOUT`: The maximum amount of time (in milliseconds) to wait for remaining data to arrive from a remote repository. Note that this timeout does not restrict the overall duration of a request, it only restricts the duration of inactivity between consecutive data packets. Non-positive values indicate no timeout.\r\n\r\nCapsule defines these variables in the application's environment:\r\n\r\n* `CAPSULE_APP`: the app ID\r\n* `CAPSULE_JAR`: the full path to the capsule's JAR\r\n* `CAPSULE_DIR`: if the JAR has been extracted, the full path of the application cache.\r\n\r\nThese values can also be accessed with `$VARNAME` in any capsule manifest attributes.\r\n\r\n### Javadoc\r\n\r\n* [capsule](http://puniverse.github.io/capsule/capsule/javadoc/Capsule.html)\r\n* [capsule-util](http://puniverse.github.io/capsule/capsule-util/javadoc/)\r\n* [capsule-build](http://puniverse.github.io/capsule/capsule-build/javadoc/)\r\n* [capsule-container](http://puniverse.github.io/capsule/capsule-container/javadoc/)\r\n\r\n## License\r\n\r\n    Copyright (c) 2014, Parallel Universe Software Co. and Contributors. All rights reserved.\r\n\r\n    This program and the accompanying materials are licensed under the terms\r\n    of the Eclipse Public License v1.0 as published by the Eclipse Foundation.\r\n\r\n        http://www.eclipse.org/legal/epl-v10.html\r\n\r\nAs Capsule does not link in any way with any of the code bundled in the JAR file, and simply treats it as raw data, Capsule is no different from a self-extracting ZIP file (especially as manually unzipping and examining the JAR's contents is extremely easy). Capsule's own license, therefore, does not interfere with the licensing of the bundled software.\r\n\r\nIn particular, even though Capsule's license is incompatible with the GPL/LGPL, it is permitted to distribute GPL programs packaged as capsules, as Capsule is simply a packaging medium and an activation script, and does not restrict access to the packaged GPL code. Capsule does not add any capability to, nor removes any from the bundled application. It therefore falls under the definition of an \"aggregate\" in the GPL's terminology.\r\n","google":"UA-25007319-1","note":"Don't delete this file! It's used internally to help with page regeneration."}